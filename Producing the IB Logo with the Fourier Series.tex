\documentclass[letterpaper, 12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{multicol}
\usepackage{graphicx}
\graphicspath{{Figures/}{./}}
\usepackage{apacite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{indentfirst}
\usepackage[justification=centering]{caption}
\usepackage{float}
\usepackage{tabularray}
\usepackage{listings}
\usepackage{url}
\lstset{
    breaklines=true,                    % sets automatic line breaking
%   breakatwhitespace=false,            % sets if automatic breaks should only happen at whitespace
    prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}} % just as an example
}


\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstdefinelanguage{JavaScript}{
    keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]',
    morestring=[b]",
    sensitive=true
}
\lstset{basicstyle=\footnotesize,breaklines=true}
\pagenumbering{roman}

\title{MATHEMATICS ANALYSIS AND APPROACHES HL
\\
Producing the IB Logo with the Fourier Series}
\author{}
\date{}

\begin{document}
\nocite{*}

\maketitle
\begin{center}
    Candidate Code:
    \\
    Session: May 2024
    \\
    Page Count:
\end{center}
\newpage

\tableofcontents
\newpage


\pagenumbering{arabic}
\setcounter{page}{1}

\section{Rationale}

I have shown interest in visual arts done through the means of software,
with particular experience in 3D modelling and animation in Blender
and Cinema 4D.

I never was experienced with drawing, therefore producing digital art
on a 2D plane using artistic skill was not of interest to me. However,
something that I came across online was the use of the Fourier Series
in order to produce vector art, which instantly intrigued me.

While vector art files such as those with the file extension ".svg" relate
to mathematics in the sense that it contains multiple graphed mathematical
relationships in order to produce an image, the method of using the Fourier
Series to produce similar art is more mathematically intriguing, as it
proves use just one expression to produce the same result done by the numerous mathematical
relationships.


\section{Aim}

The objective of this investigation is to link Fourier series with
complex numbers to create a single series that is capable
of reproducing the IB logo on the Argand plane.

\section{Plan of Action}

This exploration focuses on the following areas of math:
\begin{itemize}
    \item Integral Calculus
    \item Series
    \item Trigonometry
    \item Complex Analysis
    \item Vectors
\end{itemize}

\section{Background Information}

\subsection{Overarching idea of the Fourier Series}

A periodic function is one where the output for a particular input equals to
the output for the sum of the same input and the value of the function's period.
This can be represented mathematically as:
\begin{align*}
     & f(x) = f(x + P)
    \\
     & \text{where } P = \text{ the period of the function}
\end{align*}

The sine wave is widely known for being a periodic function for the ease of graphing
a sinusoidal wave. However, there are periodic functions that are difficult to
graph with an algebraic expression, such as one that alternates between
1 and -1 or one that is shaped as a zigzag.

This is the motivation behind the Fourier Series, which is to be able to represent
period functions that normally can't be represented by an algebraic function.

The idea behind the Fourier Series is to take an infinite sum of varying sinusoidal
functions such that a desired periodic function is produced.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{fourier_basic_visual.png}
    \caption{Visualization of the mechanism of the Fourier Series \protect\cite{sandersonWhatFourierSeries2019}. The yellow line is the periodic function resulting from the previous iteration, the red line is the sinusoidal function to be added in the next iteration.}
    \label{fig:fourier_visual}
\end{figure}

% For reference, a general formula for representing a periodic function as a Fourier Series with a
% period of \(2\pi\) is:
% \begin{equation}
%     f(t) = \frac{a_0}{2} + \sum_{n = 1}^{\infty} a_n \cos{nt} + \sum_{n=1}^{\infty} b_n\sin{nt}
% \end{equation}

% This formula won't be explored in depth, however, it is included as it will
% emphasize how the Fourier Series can be linked with complex numbers.

\subsection{Idea of drawing with the Fourier series explained with the Cartesian Plane}

The rule is for eligible drawings to be any that can be drawn by starting at one point
on a cartesian plane and, without lifting the hypothetical plane throughout the entire
sketch, return to the exact same point.

Defining the variable \(t\) as time, \(t = 0\) will represent the point in time
when the drawing began and \(t = 1\) will represent the point in time when
the drawing ended.

Each point of the drawing on the plane will be defined by \(P(x(t), y(t))\),
where \(x(t)\) and \(y(t)\) are both functions with an input of \(t\) that
indicates the coordinates after some amount of time passed of the pen's progress
through the drawing.

Assuming that any function can be represented as a Fourier Series, then
\(x(t)\) and \(y(t)\) can be any function and therefore, by extracting
the coordinates on a graph of any drawing obeying the rule described earlier,
the Fourier Series of \(x(t)\) and \(y(t)\) can be determined and therefore
produce the desired drawing for \(t\in [0,1]\)
\\

As a simple example that does not require a Fourier Series,
we can take a unit circle defined by \( x^2 + y^2 = 1 \) as the drawing.
It quickly becomes evident of what \(x(t)\) and \(y(t)\) are, as since it is a circle,
then \(x(t) = \cos(2\pi t)\) and \(y(t) = \sin(2\pi t)\).

\subsection{Enriched application to draw on the Argand Plane} \label{sec:big_guy}

Euler's formula is defined to be
\begin{equation}
    e^{it} = \cos(t) + i\sin(t)
    \label{eq:euler}
\end{equation}

Given that both the cosine function and the sine function are included in this
formula, a connection between this formula and the Fourier Series becomes evident.
The two sinusoidal functions in the formula are the core behind applying the
Fourier Series to the Argand Plane.

It is easier to think of Euler's formula to be a vector on the Argand Plane \cite{sandersonWhatFourierSeries2019}.
With just the formula given above, we have a vector with a length of 1 that rotates
counterclockwise when the value that \(e\) is raised to is positive and
clockwise when the value is negative.

Let's incorporate \(n\) and \(2\pi\) to the power in Equation \textbf{(\ref*{eq:euler})} such
that we have \(e^{n \cdot 2\pi it}\). The purpose of \(2\pi\) is to
simplify what defines a revolution, as now, for every unit of time that
\(t\) passes, a revolution will be completed. \(n, n \in \mathbb{Z}\) will define the frequency
and directionality of the rotation of the vector. If \(n > 0\), then the vector
will rotate counterclockwise and vice versa. If \(n = 2\), then the vector would
rotate by 2 revolutions for every unit of time that passes.

Lastly, let's multiply the entire power by the variable \(c_n\) to get \(c_n e^{n \cdot 2\pi it}\). This will not
only allow for the vector to be scaled but also for the starting rotation of
the vector to be defined. Let's temporarily define \(c_n\) to be:

\begin{equation*}
    c_n = A \cdot z
\end{equation*}

\(A\) will indicate the factor to which the vector will be scaled by. Because
the original length of the vector was 1, then the factor will directly indicate
the length of the vector.

\(z\) will indicate the starting rotation of the vector, which would be
\(e^{i\theta}\), where \(\theta\) is the starting rotation angle in radians.
\\

It could be imagined that the final Fourier Series that produces a desired drawing
is the sum of multiple vectors of different magnitudes rotating at different frequencies
indicated by \(n, n \in \mathbb{Z}\). Therefore, if \(f(t)\) is defined to be the
function that represents the drawing, this can be expressed mathematically
as:

\begin{equation}
    f(t) = \sum_{n=-\infty}^{\infty} c_n e^{n \cdot 2\pi it}
    \label{eq:ft_def}
\end{equation}

The main concern as of right now is how the value of \(c_n\) will be determined
for a specific drawing.

The easiest way to start off is by first considering \(c_0 e^{0 \cdot 2\pi it}\).
This can be simplified into \(c_0\), but what does this mean?
This is the vector that is rotating at a frequency of 0, which means that
it is static. It can therefore be defined to be the "centre of mass"\cite{sandersonWhatFourierSeries2019}
of the entire function.

If we take discrete intervals of \(t\) and obtain the value of \(f(t)\),
then by taking the average of all those values, we obtain a complex number
close to \(c_0\). This is illustrated by Figure \ref{fig:cnot_integ}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{cnot_integ.jpeg}
    \caption{Averaging points throughout \protect\(f(t)\) illustrated \protect\cite{sandersonWhatFourierSeries2019}. The number line represent \protect\(t\), and the red dots on the musical note represent the resulting values of \protect\(f(t)\)}
    \label{fig:cnot_integ}
\end{figure}

With finer and finer intervals of \(t\), the result
becomes more and more accurate to the value of \(c_0\), therefore it can be
said that:

% TODO: Elaborate on how you derived the equation below
\begin{equation}
    c_0 = \lim_{\Delta t \to 0} \sum_{t = 0}^{\frac{1}{\Delta t}} f(t \cdot \Delta t) \Delta t
    \label{eq:cnot_lim}
\end{equation}

From Equation \textbf{(\ref*{eq:cnot_lim})}, \(c_0\) can ultimately be expressed as:

\begin{equation}
    c_0 = \int_{0}^{1} f(t) \,dt
    \label{eq:cnot_integ}
\end{equation}


We can use the same technique for all other values of \(n\), but the problem is
for all other values of \(n\) that are not 0, the vector is rotating, therefore
it doesn't make sense to take the average of the rotating vector.

Recalling the thorough definition of \(f(t)\) stated earlier in Equation \ref*{eq:ft_def},
we can substitute Equation \ref*{eq:ft_def} into Equation \ref*{eq:cnot_integ}.

\begin{align*}
     & c_0 = \int_{0}^{1} \sum_{n=-\infty}^{\infty} c_n e^{n \cdot 2\pi it} \,dt
    \\
     & c_0 = \int_{0}^{1} \left( \cdots + c_{-1} e^{-1 \cdot 2\pi it} + c_{0} e^{0 \cdot 2\pi it} + c_{1} e^{1 \cdot 2\pi it} + \cdots \right) \,dt
    \\
     & c_0 = \cdots + \int_{0}^{1} c_{-1} e^{-1 \cdot 2\pi it} \,dt + \int_{0}^{1} c_{0} e^{0 \cdot 2\pi it} \,dt + \int_{0}^{1} c_{1} e^{1 \cdot 2\pi it} \,dt + \cdots
\end{align*}

Remember that \(\int_{0}^{1} c_{0} e^{0 \cdot 2\pi it} \,dt\) was easy to simplify
as the power cancels out from being raised to 0. In turn, it can be further
evaluated to be just \(c_0\), as shown below:

\begin{align*}
     & \int_{0}^{1} c_{0} e^{0 \cdot 2\pi it} \,dt
    \\
     & = \int_{0}^{1} c_{0} \,dt
    \\
     & = [c_{0}t]_{0}^1
    \\
     & = c_{0}
\end{align*}

Additionally, if all the other integrals were thought of as the the average of all
the points produced when its vector rotates by one revolution, then it can
be argued that each integral, when evaluated, would be 0.

This idea is illustrated in Figure \ref*{fig:circle_integ}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{circle_integ.jpeg}
    \caption{Illustration of averaging all the points on a circle \protect\cite{sandersonWhatFourierSeries2019}.}
    \label{fig:circle_integ}
\end{figure}

If we were to multiply \(f(t)\) by \(e^{-n \cdot 2\pi it}\), then an effect can occur
where all of the power's exponents will decrease by \(n\). Ultimately, we will
get a similar scenario in the summation of all the integrals where
all integrals are evaluated to become 0 except for the integral
where \(n = 0\), which evaluates to \(c_0\). However, the multiplication
of the two powers will cause the integral of some \(n\) value to simplify to just
\(c_n\).

This mechanism is mathematically shown below.
\begin{align*}
     & n = 1
    \\
     & c_1 = \int_{0}^{1} f(t) e^{-1 \cdot 2\pi it} \,dt
    \\
     & c_1 = \cdots + \int_{0}^{1} c_{-1} e^{-1 \cdot 2\pi it} \cdot e^{-1 \cdot 2\pi it} \,dt
    \\
     & + \int_{0}^{1} c_{0} e^{0 \cdot 2\pi it} \cdot e^{-1 \cdot 2\pi it} \,dt + \int_{0}^{1} c_{1} e^{1 \cdot 2\pi it} \cdot e^{-1 \cdot 2\pi it} \,dt + \cdots
    \\
     & c_1 = \cdots + \int_{0}^{1} c_{-1} e^{-2 \cdot 2\pi it} \,dt + \int_{0}^{1} c_{0} e^{-1 \cdot 2\pi it} \,dt + \int_{0}^{1} c_{1} e^{0 \cdot 2\pi it} \,dt + \cdots
    \\
     & c_1 = \cdots + 0 + 0 + c_1 + 0 + 0 + \cdots
    \\
     & c_1 = c_1
\end{align*}

Therefore, \(c_n\) can be defined as:

\begin{equation}
    c_n = \int_{0}^{1} f(t) e^{-n \cdot 2\pi it} \,dt
    \label{eq:cn_integ}
\end{equation}

Equation \ref*{eq:cn_integ} is what will be used in order to
determine each value of \(c_n\)
\\

All concepts of this section come from \cite{sandersonWhatFourierSeries2019}.


\subsection{Bézier curves}

\subsubsection{Linear interpolation}

Suppose there is a free moving point \(P\) on the line drawn between
the stationary points \(P_0\) and \(P_1\) as illustrated on
Figure \ref*{fig:2_point_bezier}.

\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{2_point_bezier.png}
    \caption{2 point Bézier \protect\cite{holmerBeautyBezierCurves2021}.}
    \label{fig:2_point_bezier}
\end{figure}

The position of \(P\) along the line will be defined by \(t\), which
is thought of to be the percentage that \(t\) is along the line,
where \(t = 100\%\) is located at \(P_1\) and \(t = 0\%\) is located
at \(P_0\). This process is called linear interpolation (lerp) and
can be expressed mathematically as:

\begin{equation}
    P = lerp(P_0, P_1, t) = (1-t)P_0 + tP_1
    \label{eq:lerp_def}
\end{equation}
where \(lerp(P_0, P_1, t)\) is the function that represents the
process of lerping.


\subsubsection{Cubic Bézier curves}

While there are many types of Bézier curves, this investigation will
only focus on Cubic Bézier curves as they are the only type of Bézier curve used in the IB Logo.

Suppose that instead of just 2 points, there are 4 points on the
plane (\(P_0, P_1, P_2, P_3\)). The lines are drawn so that
\(P_0\) connects to \(P_1\), \(P_1\) connects to \(P_2\), and
\(P_2\) connects to \(P_3\) such that \(P_0\) and \(P_3\) are both
endpoints.

Each line segment has its own individual moving point, with all moving
points "lerping" according to the same universal \(t\) value.

Lines can then be drawn between these new moving points, and
these points lerp according to the same \(t\) value.

This process of adding points on lines and drawing new lines
until just one moving point along a single line is created, which
will be the "pen" of the Bézier curve.

This is all illustrated by Figures \ref*{fig:cubic_ill_mid} and \ref*{fig:cubic_ill_end}.

\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{cubic_ill_mid.png}
    \caption{Cubic Bézier around the middle of its lerp \protect\cite{holmerBeautyBezierCurves2021}.}
    \label{fig:cubic_ill_mid}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{cubic_ill_end.png}
    \caption{Cubic Bézier nearing the end of its lerp \protect\cite{holmerBeautyBezierCurves2021}.}
    \label{fig:cubic_ill_end}
\end{figure}

\subsubsection{Bernstein Polynomial Form}

\begin{figure}[H]
    \centering
    \includegraphics[width=.8\textwidth]{labelled_cubic.png}
    \caption{Cubic Bézier curve with labelled points \protect\cite{holmerBeautyBezierCurves2021}.}
    \label{fig:labelled_cubic}
\end{figure}

We can derive a general formula for \(P\) in terms of \(P_0, P_1, P_2, P_3, t\) by expanding out
all of the lerp functions for each point in a Cubic Bézier curve
and substituting when necessary, as shown below. Variables are
with reference to Figure \ref*{fig:labelled_cubic}.

\begingroup
\allowdisplaybreaks
\begin{align*}
     & A = lerp(P_0, P_1, t)
    \\
     & B = lerp(P_1, P_2, t)
    \\
     & C = lerp(P_2, P_3, t)
    \\
     & D = lerp(A, B, t)
    \\
     & E = lerp(B, C, t)
    \\
     & P = lerp(D, E, t)
    \\
    \\
     & \text{From Equation } \protect\ref*{eq:lerp_def}
    \\
     & lerp(P_0, P_1, t) = (1-t)P_0 + tP_1
    \\
    \\
     & A = (1-t)P_0 + tP_1
    \\
     & B = (1-t)P_1 + tP_2
    \\
     & C = (1-t)P_2 + tP_3
    \\
     & D = (1-t)A + tB
    \\
     & E = (1-t)B + tC
    \\
     & P = (1-t)D + tE
    \\
    \\
     & P = P_0(-t^3+3t^2-3t+1) + P_1(3t^3-6t^2+3t)
    \\
     & + P_2(-3t^3+3t^2) + P_3(t^3)
\end{align*}
\endgroup

Therefore, the general formula for \(P\) in terms of
\(P_0, P_1, P_2, P_3, \text{and} t\) is

\begin{equation} \label{eq:pFormula}
    P = P_0(-t^3+3t^2-3t+1) + P_1(3t^3-6t^2+3t) + P_2(-3t^3+3t^2) + P_3(t^3)
\end{equation}

All information regarding Bézier curves come from \cite{holmerBeautyBezierCurves2021}.

\subsection{Composition of ".svg" files}

SVG files are "XML-based vector image format for defining two dimensional
graphics"\cite{SVG2023}.

An SVG's two dimensional size is defined by the "viewBox" attribute,
which will indicate the width and height of the canvas.

There are many attributes for drawing predefined shapes, but what
we are concerned with is the "path" attribute, which allows for custom
shapes and is what the IB logo will be composed of.

The "path" attribute will be defined by various curves that are indicated
by letters. The letters that are of concern in this investigation are
listed below.
\begin{itemize}
    \item M: Move the pen to somewhere without drawing a line
    \item C: Cubic Bézier defined by the starting location, 2 control points, and an indicated end location
    \item L: Draw a vertical line to some coordinate
    \item V: Draw a vertical line up to some y-coordinate
    \item Z: Draw a straight line back to the first point of the path
\end{itemize}

Note that when the letter is lowercase, the coordinates specified will
be relative to the current position (ex. \(m~\Delta x~\Delta y\)). If the letter is uppercase, the
coordinates specified will be absolute to the canvas (ex. \(M~x~y\)).

All information regarding paths come from \cite{mozilladevelopernetworkPathsSVGScalable2023}.




\section{Methodology}

\subsection{Analysis of the ".svg" File} \label{svgAnalysis}

On a canvas of height 198.426px and width 198.425px,
a few lines of the path of the IB Logo is presented below,
with the entire path presented in Section \ref*{app:fullSVG}
of the appendix
\cite{internationalbaccalaureateorganisationInternationalBaccalaureateLogo2013}. \textbf{Note: SVG files interpret positive y-values as downwards.}

\begin{verbatim}
    <path fill="url(#SVGID_1_)" d="
    M198.425,99.155
    c 0,54.833 -45.075,99.271 -100.685,99.271
    c -47.27, 0 -86.91 -32.11 -97.74 -75.416
    c 19.703 -0.222, 38.391 -4.567, 55.26 -12.149
    V 72.226
    ...
    C 68.199, 48.705, 71.582, 47.359, 74.363, 44.669
    z"/>
\end{verbatim}

Disregarding any "Move" actions, there are 54 pen strokes
in total for the IB Logo. This means that for the starting piecewise
form of \(f(t)\), each piece will have a domain of \(\frac{1}{54}(n-1) \le t < \frac{1}{54}n\),
where \(n\) represents the index of the current pen stroke.

The contents of this path was moved into an Excel Spreadsheet for
the sake of organization, with part of the spreadsheet shown
in Figure \ref*{fig:svgxlsx}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{svgxlsx.png}
    \caption{Path data imported in an Excel Spreadsheet}
    \label{fig:svgxlsx}
\end{figure}

Using Javascript under the NodeJS Runtime, this spreadsheet can
be read using the NPM Package "read-excel-file" \cite{kuchumovReadexcelfile}.
This package will parse the spreadsheet into an array of rows,
with each row being an array of cells. Then, the code presented
below will iterate through each row, with access to all the cells
in that row indexed by zero-based numbering.

\begin{lstlisting}[language=JavaScript]
    readXlsxFile('./SVG_Coordinate_Spreadsheet.xlsx')
    .then((rows) => {
        // `rows` is an array of rows
        // each row being an array of cells.
        rows.forEach(row => {
            // iterate through each row, accessing the
            // cells of each row
        });
    })
\end{lstlisting}

For each row, the code checks if the operation for the current
row is relevant for drawing. Only "Move" (M) is ignored, and
all "Z" operations were written down as "line" (L) operations.
Using the data within each row, the parameter of \(c_n\) can be
computed for each value of \(n\).

\subsection{Computation of parameters}

Given that \(f(t)\) is able to be determined as a piecewise function
from the previous section, the desired summation representing
\(f(t)\) can be determined.

Referring back to Section \ref*{sec:big_guy}, \(c_n\) is defined as:

\begin{equation*}
    c_n = \int_{0}^{1} f(t) e^{-n \cdot 2\pi it} \,dt
\end{equation*}

This means that every \(c_n\) must be determined individually. Therefore,
it becomes evident that it is unreasonable to evaluate the infinite sum of
\(f(t) = \sum_{n=-\infty}^{\infty} c_n e^{n \cdot 2\pi it}\), and that
the limits of the summation must be defined.

Let's rewrite \(f(t)\) as:
\begin{equation*}
    f(t) = \sum_{n=-k}^{k} c_n e^{n \cdot 2\pi it}
\end{equation*}

so that \(k\) indicates the selected frequency of the two fastest vectors
that are spinning in opposite directions to each other.

As \(k \to \infty\), \(f(t)\) becomes more and more accurate to
the original drawing, which will be demonstrated by performing distinct
analyses for various values of \(k\).

\subsubsection{Approach to integration} \label{sec:approachInteg}

\begin{equation*}
    c_n = \int_{0}^{1} f(t) e^{-n \cdot 2\pi it} \,dt
\end{equation*}

The integral above can be evaluated for some value of \(n\) by
taking some small value to represent \(\Delta t\), in which
by summing up the values from \(f(t) e^{-n \cdot 2\pi it}\)
produced by each increment of \(t\) by \(\Delta t\), a value close
to the original integral can be determined \cite{sandersonWhatFourierSeries2019}.
This is known as a Riemann Sum \cite{RiemannSum2023}.

\begin{equation}
    c_n = \sum_{t = 0}^{\frac{1}{\Delta t}} f(t \cdot \Delta t) e^{-n \cdot 2\pi i(t \cdot \Delta t)} \Delta t
    \label{eq:cn_riemann_sum}
\end{equation}

Because a small value of \(\Delta t\) must be used, \(c_n\) must
be evaluated through a computer. Additionally, since the original
version of \(f(t)\) can be thought of as a piecewise function composed
of Bézier curves and lines, then Equation \ref*{eq:cn_riemann_sum}
must be split up into multiple sums, each accounting for the domain
of each piece of the piecewise function (\(\frac{1}{54}(n-1) \le t < \frac{1}{54}n\)).
From this consideration, Equation \ref*{eq:cn_riemann_sum} can be
expressed as the following:

\begin{equation}
    \begin{aligned} \label{eq:riemann_Expanded}
         & c_n = \sum_{t = 0}^{(\frac{1}{54})(\frac{1}{\Delta t})} f(t \cdot \Delta t) e^{-n \cdot 2\pi i(t \cdot \Delta t)} \Delta t
        + \sum_{t = (\frac{1}{54})(\frac{1}{\Delta t})}^{(\frac{2}{54})(\frac{1}{\Delta t})} f(t \cdot \Delta t) e^{-n \cdot 2\pi i(t \cdot \Delta t)} \Delta t
        \\
         & + \cdots
        + \sum_{t = (\frac{53}{54})(\frac{1}{\Delta t})}^{(\frac{54}{54})(\frac{1}{\Delta t})} f(t \cdot \Delta t) e^{-n \cdot 2\pi i(t \cdot \Delta t)} \Delta t
    \end{aligned}
\end{equation}

Additionally, in order to evaluate the complete range of \(f(t)\)
for some section, \(f(t)\) must take in the complete domain of
\([0, 1]\). The reason for this will be elaborated on in
Section \ref*{sec:bezierCalc}, but because each section will only
account for the same domain defined by \([\frac{1}{54}(n-1), \frac{1}{54}n)\),
then \(f(t)\) must take an input of a manipulated value of \(t\).
To simplify this manipulation, let's make every summation in
Equation \ref*{eq:riemann_Expanded} have limits from 0 to
\(\frac{1}{54\Delta t}\) and add the initial time of each
section to \(t \cdot \Delta t\) in the expression
\(e^{-n \cdot 2\pi i(t \cdot \Delta t)}\) so that
the calculation for such expression stays absolute to the universal
time passage. The input of \(f(t)\) can therefore be multiplied
by 54 so that when the upper limit of the summation (\(\frac{1}{54\Delta t}\))
is multiplied by 54 and \(\Delta t\), then the resulting value
is 1 (\(\frac{1}{54\Delta t} \cdot 54\Delta t = 1\)).
This therefore offers a domain for \(f(t)\) from 0 to 1 even if
\(t \in [\frac{1}{54}(n-1), \frac{1}{54}n)\) for each
summation.


Overall, if we let \(f_n(t)\) equal to the function \(f(t)\) isolated
to just the \(n^{\text{th}}\) section,
Equation \ref*{eq:cn_riemann_sum} can
be expressed as:

\begin{equation}
    \begin{aligned} \label{eq:riemann_Codefriendly}
         & c_n = \sum_{t = 0}^{\frac{1}{54\Delta t}} f_1(54t \cdot \Delta t) e^{-n \cdot 2\pi i(t \cdot \Delta t + 0)} \Delta t
        \\
         & + \sum_{t = 0}^{\frac{1}{54\Delta t}} f_2(54t \cdot \Delta t) e^{-n \cdot 2\pi i(t \cdot \Delta t + \frac{1}{54})} \Delta t
        \\
         & + \sum_{t = 0}^{\frac{1}{54\Delta t}} f_3(54t \cdot \Delta t) e^{-n \cdot 2\pi i(t \cdot \Delta t + \frac{2}{54})} \Delta t
        \\
         & + \cdots +
        \sum_{t = 0}^{\frac{1}{54\Delta t}} f_{54}(54t \cdot \Delta t) e^{-n \cdot 2\pi i(t \cdot \Delta t + \frac{53}{54})} \Delta t
    \end{aligned}
\end{equation}

Therefore, the approach of the code will be to iterate through
each value of \(n\) from \(-k \le n \le k\), and evaluate
the Riemann Sum using Equation \ref*{eq:riemann_Codefriendly}.

The computer program saves a Dictionary composed of a searchable key,
which will composed of all of the possible \(n\) values within
a defined range that comes from a user input specifying what
\(k\) equals. Then, each key will have an associated value
that will start as being defined to be \(0 + 0i\), which
is achievable through the "complex" object offered by the
"mathjs" NPM package \cite{dejongMathjs}.

Then, for each row of the Excel Spreadsheet (in which the process of
iterating through every row was explained in Section \ref*{svgAnalysis}),
every possible value for \(n\) is analyzed with a for loop,
allowing the program to evaluate the value of \(c_n\) associated with
each row.
% TODO: find a way to incorporate the for loop code in here

The following code is equivalent to Equation \ref*{eq:riemann_Codefriendly}.
\textbf{Note: "f" represents f(t) and
    the calculation for it will differ based on whether
    a Bézier curve or a Straight Line is being drawn.
    The calculation for f(t) will be elaborated on in
    Section \ref*{sec:bezierCalc}.}

\begin{lstlisting}[language=JavaScript]
    for(let t = 0; t < 1/sectionCount/dt; t++){
        const f = null;
        const add = math.multiply(dt, math.multiply(f, math.pow(math.e, math.multiply(math.complex(0, 1), -2 * n * math.pi * (t * dt + row[9])))));
        CnDict[n] = math.add(CnDict[n], add);
    }
\end{lstlisting}

\subsubsection{Calculation for Cubic Bézier curves} \label{sec:bezierCalc}

Recalling that Equation \ref*{eq:pFormula} stated that

\begin{equation*}
    P = P_0(-t^3+3t^2-3t+1) + P_1(3t^3-6t^2+3t) + P_2(-3t^3+3t^2) + P_3(t^3)
\end{equation*}

This was originally meant for when \(P, P_0, P_1, P_2, P_3\)
were ordered pairs on a Cartesian Plane. However, because
multiplication between a scalar and a Cartesian Vector operates
similarly to multiplication between a scalar and a complex number,
then \(P_0, P_1, P_2, P_3\) are allowed to be expressed as complex
numbers. Given this condition, \(P\) would be equivalent to \(f(t)\)
because \(P\) is the Cartesian vector for all points defined
by a Bézier curve, and if the result representing \(P\) was a complex
number, then \(P\) is representable as a function of \(t\).

Something crucial to consider is that \(t\) in Equation \ref*{eq:pFormula}
is \textbf{not} the time passage in drawing the IB logo but rather
the lerp of the Bézier curve from 0 to 1. To distinguish this distinction,
the function will instead take in an input \(j\), with the relationship
between \(j\) and \(t\) being established in Section \ref*{sec:approachInteg}
to be \(j = 54t\).

Ultimately, the Bézier curve can be expressed as:

\begin{equation} \label{eq:f_of_j_Cubic}
    f(j) = P_0(-j^3+3j^2-3j+1) + P_1(3j^3-6j^2+3j) + P_2(-3j^3+3j^2) + P_3(j^3)
\end{equation}

The value of \(f(j)\) is evaluated through the
following code, which is equivalent to Equation \ref*{eq:f_of_j_Cubic}:

\begin{lstlisting}[language=JavaScript]
    const sectionCount = 54;

    function subTimeCalc(t){
        return sectionCount * t;
    };

    const fCubicCalc = (t, r) => {
        const P0 = math.complex(r[1], r[2]);
        const P1 = math.complex(r[3], r[4]);
        const P2 = math.complex(r[5], r[6]);
        const P3 = math.complex(r[7], r[8]);

        let j = subTimeCalc(t);
        const ret = 
            math.add(
                math.add(
                    math.multiply(P0, (-1*math.pow(j,3) + 3*math.pow(j,2) - 3*j + 1)),
                    math.multiply(P1, (3*math.pow(j,3) - 6*math.pow(j,2) + 3*j))
                ),
                math.add(
                    math.multiply(P2, (-3*math.pow(j,3) + 3*math.pow(j,2))),
                    math.multiply(P3, (math.pow(j,3)))
                )
            )
        return ret;
    };
\end{lstlisting}

\subsubsection{Calculation for Straight Lines}

In Section \ref*{sec:bezierCalc}, it was mentioned that \(t\) cannot
be used as the input of \(f(t)\) as the original meaning of \(t\) in
such context was the lerp progression in the Bézier curve.

While \(t\) could be used in the calculation of \(f(t)\) for straight lines,
it is actually better to continue to use \(j = 54t\), as this allows
for consistency and will make the derived equations relevant in the section
to be way cleaner than if \(t\) was used.

Every line will have an initial point at \(j=0\) that can be
expressed as \(x_0 + iy_0\), as well as a final point at \(j=1\)
that can be expressed as \(x_1 + iy_1\).

Because the pathway between these two points is a straight line,
then two linear functions can be found for \(x\) and \(y\) that
are in terms of \(j\). This means that \(f(j)\) can be expressed
as follows:

\begin{equation*}
    f(j) = x(j) + iy(j)
\end{equation*}

The formula for \(x(j)\) is derived below.

\begin{align*}
     & x(j) = mj + b
    \\
     & b = x_0
    \\
     & m = \frac{\Delta x}{\Delta j}
    \\
     & = \frac{x_1 - x_0}{1 - 0}
    \\
     & = x_1 - x_0
    \\
     & x(j) = (x_1 - x_0)j + x_0
\end{align*}

\(y(j)\) can be said to have a similar formula, as \(x_0, x_1\) are
simply replaced by \(y_0, y_1\), and \(\Delta j\) remains 1.

Ultimately, \(f(j)\) can be expressed as follows:

\begin{equation}
    f(j) = ((x_1 - x_0)j + x_0) + i((y_1 - y_0)j + y_0)
\end{equation}

This is evaluated through the following code:
\begin{lstlisting}[language=JavaScript]
    const f =
    math.add(
        math.add(
            row[1],
            math.multiply(
                subTimeCalc(t * dt),
                row[3] - row[1]
            )
        ),
        math.multiply(
            math.complex(0, 1),
            math.add(
                row[2],
                math.multiply(
                    subTimeCalc(t * dt),
                    math.add(
                        row[4],
                        -1 * row[2]
                    )
                )
            )
        )
    );
\end{lstlisting}

\subsection{Rendering the final image}

Recalling that the end result of \(f(t)\) is defined as the equation
below, then rendering the final image is just a matter of going
through various values of \(t\), summing up \(c_n e^{n \cdot 2\pi it}\)
for all values of \(k\), and rendering the result by placing
the real parts of \(f(t)\) on the horizontal axis on a plane,
and placing the imaginary part of \(f(t)\) on the vertical axis
on a plane.

\begin{equation*}
    f(t) = \sum_{n=-k}^{k} c_n e^{n \cdot 2\pi it}
\end{equation*}

Because all possible \(n\) values within an given domain and
their associated values for \(c_n\) were stored in a dictionary,
then iterating through the dictionary will allow for accessing
all of the \(c_n\) values properly linked with their associated \(n\) value.

The code that calculates \(f(t)\) and renders the result is presented below:
\begin{lstlisting}[language=JavaScript]
    let universalTime = 0;

    function plotPoint(x, y){
        const adjX = x + 99.2125;
        const adjY = -y + 99.213;
        ctx.strokeStyle = 'rgba(255,0,0,1)';
        ctx.beginPath();
        ctx.lineTo(adjX-1, adjY);
        ctx.lineTo(adjX+1, adjY);
        ctx.stroke();
    }

    function finalF(){
        while(universalTime <= 1){
            let curr = math.complex(0, 0);
            Object.entries(CnDict).forEach(pair => {
                [currN, cn] = pair;
                //for a specific time
                //calculate f(t)
                //plot
                curr = math.add(
                    curr,
                    math.multiply(
                        cn,
                        math.pow(
                            math.e,
                            math.multiply(
                                math.complex(0, 1),
                                currN * 2 * math.pi * universalTime
                            )
                        )
                    )
                )
            });
            plotPoint(curr.re, curr.im);
            universalTime += dt;
        }
    }

    finalF();
    console.log('<img src="' + canvas.toDataURL() + '" />');
\end{lstlisting}

\section{Results}

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{5.png}
    \caption{\protect\(\Delta t = 0.0001, k = 5\), 10 spinning vectors, 11 total vectors}
    % \label{fig:svgxlsx}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{25.png}
    \caption{\protect\(\Delta t = 0.0001, k = 25\), 50 spinning vectors, 51 total vectors}
    % \label{fig:svgxlsx}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\textwidth]{1000.png}
    \caption{\protect\(\Delta t = 0.00001, k = 1000\), 2000 spinning vectors, 2001 total vectors}
    % \label{fig:svgxlsx}
\end{figure}

\section{Conclusion}

Throughout this investigation, the aim of converting
the IB logo into a Fourier Series and in turn
rendering the IB logo using its Fourier Series has been
accomplished. In addition to that, connecting
Fourier Series with complex numbers has enabled
the ability to handle a two-dimensional
logo without separating it into two components.

The primary limitation with my approach to this investigation
was the inflexibility in terms of what the
computer program could convert into a Fourier Series.
Ideally, the program should take in a ".svg" file and
automatically convert the path to Bézier curves
as representation of what \(f(t)\) is
prior to being converted to a Fourier Series.
This is all due to transferring all the values
to an Excel spreadsheet, which makes it easier to
see the moving parts but prevents the program
from analyzing any kind of vector art
without the conversion of an ".svg" file into
a spreadsheet and modifications to the code
(e.g. number of Bézier curves or lines, size of canvas).

Another limitation is that the method of
going through the ".svg" path without
considering continuity resulted in the artifacts present
in the final result. This may be
prevented in a future investigation
by coding a program to begin
parsing a separate \(f(t)\) function
after detection of a significant and sudden
change between the previous and current
complex values.

I expect that I will be able to handle learning
Fourier Series in some university course
in the future with ease. Although it is likely
that Fourier Series will be taught in a course
in the context of real numbers using
\(\sin(t)\) and \(\cos(t)\) instead of \(e^{it}\),
the same mechanisms will still be present around
determining the coefficients for each term of
the series, which has been the largest hurdle
for me in comprehending Fourier Series in this
investigation.

The main area of extension of this investigation
is the way in which the integral for \(c_n\) was
evaluated where it was evaluated as a Riemann Sum.
It is possible to evaluate this integral through
integration by parts; however, the challenge
when incorporating this into the method of this investigation
is that because each Bézier curve is evaluated
between 0 and 1, then numerous integrals
must be evaluated with a unique transformation
to each Bézier curve piece part of the original
piece-wise \(f(t)\) function thereby resulting
in more and more complicated integrals
for pieces of the function nearing the end boundary.

\bibliographystyle{apacite}
\bibliography{IB_MATH_IA.bib}

\appendix

\section{Full SVG Path} \label{app:fullSVG}

\begin{verbatim}
    <path fill="url(#SVGID_1_)" d="
    M198.425,99.155
    c 0,54.833 -45.075,99.271 -100.685,99.271
    c -47.27, 0 -86.91 -32.11 -97.74 -75.416
    c 19.703 -0.222, 38.391 -4.567, 55.26 -12.149
    V 72.226
    c 0 -3.062 -1.079 -5.3 -3.234 -6.716
    c -2.151 -1.409 -5.975 -2.12 -11.479 -2.12
    v -3.579
    c 7.295 -0.24, 13.984 -0.665, 20.063 -1.267
    c 6.086 -0.604, 11.331 -1.513, 15.74 -2.721
    l 0.092, 56.113
    c 0, 3.182, 0, 6.654, 0, 10.422
    c 0, 3.657 -0.055, 7.25 -0.178, 10.782
    c -0.122, 3.537 -0.303, 6.833 -0.539, 9.895
    c -0.242, 3.065 -0.54, 5.653 -0.901, 7.771
    c 5.983, 3.424, 12.621, 6.249, 19.921, 8.49
    c 7.299, 2.239, 14.115, 3.353, 20.455, 3.353
    c 5.383, 0, 10.589 -0.795, 15.612 -2.387
    c 5.026 -1.59, 9.484 -3.916, 13.367 -6.99
    c 3.889 -3.066, 7.033 -6.833, 9.428 -11.322
    c 2.39 -4.485, 3.585 -9.563, 3.585 -15.226
    c 0 -5.188 -0.898 -9.969 -2.694 -14.335
    c -1.795 -4.368 -4.313 -8.139 -7.552 -11.329
    c -3.234 -3.19 -7.06 -5.69 -11.494 -7.52
    c -4.437 -1.834 -9.286 -2.749 -14.557 -2.749
    c -3.955, 0 -7.993, 0.687 -12.126, 2.048
    c -4.139, 1.371 -7.879, 3.065 -11.231, 5.079
    V 81.217
    c 18.133 -18.684, 30.894 -42.471, 35.809 -68.97
    c -22.443 -9.396 -48.452 -10.619 -73.052 -1.412
    C 32.967, 21.061, 12.981, 42.053, 3.409, 67.056
    c 9.221 -26.919, 30.12 -49.704, 59.155 -60.579
    c 24.245 -9.068, 49.573 -8.27, 71.696, 0.248
    c 0.002 -0.021, 0.011 -0.045, 0.014 -0.063
    C 171.81, 21.082, 198.425, 57.046, 198.425, 99.155
    z 
    M 100.598, 149.993
    c 2.746, 4.661, 7.408, 6.986, 13.987, 6.986
    c 6.564, 0, 11.233 -2.325, 13.985 -6.986
    c 2.749 -4.652, 4.123 -11.988, 4.123 -22.013
    c 0 -10.014 -1.374 -17.353 -4.123 -22.008
    c -2.752 -4.657 -7.421 -6.979 -13.985 -6.979
    c -6.58, 0 -11.242, 2.322 -13.987, 6.979
    c -2.75, 4.655 -4.124, 11.994 -4.124, 22.008
    C 96.474, 138.005, 97.848, 145.341, 100.598, 149.993
    z 
    M 74.363, 44.669
    c 2.793 -2.686, 4.185 -6.045, 4.185 -10.084
    c 0 -4.037 -1.392 -7.397 -4.185 -10.086
    c -2.781 -2.692 -6.165 -4.037 -10.129 -4.037
    c -3.968, 0 -7.351, 1.345 -10.137, 4.037
    c -2.79, 2.688 -4.181, 6.049 -4.181, 10.086
    c 0, 4.039, 1.391, 7.398, 4.181, 10.084
    c 2.786, 2.69, 6.168, 4.036, 10.137, 4.036
    C 68.199, 48.705, 71.582, 47.359, 74.363, 44.669
    z"/>
\end{verbatim}

\section{Full Calculation and Graphing Program Code}



\lstinputlisting[language=JavaScript]{calcPresentation.js}

\end{document}